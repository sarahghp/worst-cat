<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>C U B E</title>
</head>
<body>
  <canvas id="c" width="400" height="500"></canvas>
  <script id="3d-vertex-shader" type="x-shader/x-vertex">

    attribute vec4 a_position;
    attribute vec4 a_color;

    uniform mat4 u_matrix;

    varying vec4 v_color;


    void main() {
      // Multiply the position by the matrix.
      gl_Position = u_matrix * a_position;
      v_color = a_color;
    }

  </script>

  <script id="3d-fragment-shader" type="x-shader/x-fragment">

    // fragment shaders don't have a default precision so we need
    // to pick one. mediump is a good default
    precision mediump float;
    varying vec4 v_color;


    void main() {
      // gl_FragColor is a special variable a fragment shader
      // is responsible for setting
      gl_FragColor = v_color;
    }

  </script>

  <script>

    console.log('Loaded.');
    window.onload = main;

    function main() {

      // create context
      var canvas = document.getElementById("c");
      var gl = canvas.getContext("webgl");

      if (!gl) {
       console.log('Wat, no gl.');
      }

      gl.clearColor(1.0, 1.0, 1.0, 1.0);  // Clear to white, fully opaque
      gl.clearDepth(1.0);                 // Clear everything
      gl.enable(gl.DEPTH_TEST);           // Enable depth testing
      gl.depthFunc(gl.LEQUAL);            // Near things obscure far things
      // create and bind buffers

      var vertices = [
        // Front face
        0.0,    0.0,    100.0,
        100.0,  0.0,    100.0,
        100.0,  100.0,  100.0,
        0.0,    100.0,  100.0,

        // Back face
        0.0,    0.0,    0.0,
        0.0,    100.0,  0.0,
        100.0,  100.0,  0.0,
        100.0,  0.0,    0.0,

        // Top face
        0.0,    100.0,  0.0,
        0.0,    100.0,  100.0,
        100.0,  100.0,  100.0,
        100.0,  100.0,  0.0,

        // Bottom face
        0.0,    0.0,    0.0,
        100.0,  0.0,    0.0,
        100.0,  0.0,    100.0,
        0.0,    0.0,    100.0,

        // Right face
        100.0,    0.0,  0.0,
        100.0,  100.0,  0.0,
        100.0,  100.0,  100.0,
        100.0,    0.0,  100.0,

        // Left face
        0.0,    0.0,    0.0,
        0.0,    0.0,    100.0,
        0.0,  100.0,    100.0,
        0.0,  100.0,    0.0
      ];

      var colors = generateColors();

      // This array defines each face as two triangles, using the
      // indices into the vertex array to specify each triangle's
      // position.

      var cubeVertexIndices = [
        0,  1,  2,      0,  2,  3,    // front
        4,  5,  6,      4,  6,  7,    // back
        8,  9,  10,     8,  10, 11,   // top
        12, 13, 14,     12, 14, 15,   // bottom
        16, 17, 18,     16, 18, 19,   // right
        20, 21, 22,     20, 22, 23    // left
      ];

      // create, link, and use program
      var program = createProgramFromScripts(gl, '3d-vertex-shader', '3d-fragment-shader');
      gl.useProgram(program);

      // set attribute and uniform locations
      var positionLocation = gl.getAttribLocation(program, "a_position");
      gl.enableVertexAttribArray(positionLocation);

      var colorLocation = gl.getAttribLocation(program, "a_color");
      gl.enableVertexAttribArray(colorLocation);

      var matrixLocation = gl.getUniformLocation(program, "u_matrix");

      var positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      gl.vertexAttribPointer(
            positionLocation, 3, gl.FLOAT, false, 0, 0);

      var colorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
      gl.vertexAttribPointer(
          colorLocation, 4, gl.FLOAT, false, 0, 0);

      var cubeVerticesIndexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer);

      // Now send the element array to GL

      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
          new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);

      function drawCube(translation, rotation, scale){
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        rotation = rotation.map((r, i) => r += (.01 * i))
        translation = translation.map((t, i) => {
          if (i < 2){
            return clamp(t + plusOrMinus(0.1), 0, 400, i + 1);
          } else {
            return t;
          }
        })

        // Compute the matrix
        var matrix = m4.projection(gl.canvas.clientWidth, gl.canvas.clientHeight, 400);
        matrix = m4.translate(matrix, translation[0], translation[1], translation[2]);
        matrix = m4.xRotate(matrix, rotation[0]);
        matrix = m4.yRotate(matrix, rotation[1]);
        matrix = m4.zRotate(matrix, rotation[2]);
        matrix = m4.scale(matrix, scale[0], scale[1], scale[2]);

        // Set the matrix.
        gl.uniformMatrix4fv(matrixLocation, false, matrix);

        // Draw the cube.
        gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

        requestAnimationFrame(drawCube.bind(null, translation, rotation, scale))
      }

      var initTranslation = [gl.canvas.clientWidth/3, gl.canvas.clientHeight/3, 40],
          initRotation    = [1, 1, 1],
          initScale       = [1, 1, 1];

      requestAnimationFrame(drawCube.bind(null, initTranslation, initRotation, initScale))
    }




    ////////////////////////////////////////////////////////
    ///// ðŸŽ¨ DRAWING HELPER FUNCTIONS /////////////////////
    ////////////////////////////////////////////////////////

    function generateColors() {
      var colors = [
        normalizeColor([255,  240,  85,   255]),    // Front face
        normalizeColor([146,  149,  152,  255]),    // Back face
        normalizeColor([12,   182,  145,  255]),    // Top face
        normalizeColor([255,    0,  72,   255]),    // Bottom face
        normalizeColor([185,  119,  211,  255]),    // Right face
        normalizeColor([255,  137,  147,  255])     // Left face
      ];

      var generatedColors = [];

      for (j=0; j<6; j++) {
        var c = colors[j];

        for (var i=0; i<4; i++) {
          generatedColors = generatedColors.concat(c);
        }
      }

      return generatedColors;
    }

    function normalizeColor(color){
      return color.map(function(c){
        return c/255;
      })
    }



    ////////////////////////////////////////////////////////
    ///// ðŸ”¢ MATHING HELPER FUNCTIONS /////////////////////
    ////////////////////////////////////////////////////////

    function plusOrMinus(range){
      var n = Math.random() * (range * 2); // .11 * (.02)
      return n - range;
    }

    function clamp(val, min, max, variation) {
      if (val > max) {
        return val - variation;
      } else if (val < min) {
        return val + variation;
      } else {
        return val;
      }
    }

    // All the matrix maths
    var m4 = {

      projection: function(width, height, depth) {
        // Note: This matrix flips the Y axis so 0 is at the top.
        return [
           2 / width, 0, 0, 0,
           0, -2 / height, 0, 0,
           0, 0, 2 / depth, 0,
          -1, 1, 0, 1,
        ];
      },

      multiply: function(a, b) {
        var a00 = a[0 * 4 + 0];
        var a01 = a[0 * 4 + 1];
        var a02 = a[0 * 4 + 2];
        var a03 = a[0 * 4 + 3];
        var a10 = a[1 * 4 + 0];
        var a11 = a[1 * 4 + 1];
        var a12 = a[1 * 4 + 2];
        var a13 = a[1 * 4 + 3];
        var a20 = a[2 * 4 + 0];
        var a21 = a[2 * 4 + 1];
        var a22 = a[2 * 4 + 2];
        var a23 = a[2 * 4 + 3];
        var a30 = a[3 * 4 + 0];
        var a31 = a[3 * 4 + 1];
        var a32 = a[3 * 4 + 2];
        var a33 = a[3 * 4 + 3];
        var b00 = b[0 * 4 + 0];
        var b01 = b[0 * 4 + 1];
        var b02 = b[0 * 4 + 2];
        var b03 = b[0 * 4 + 3];
        var b10 = b[1 * 4 + 0];
        var b11 = b[1 * 4 + 1];
        var b12 = b[1 * 4 + 2];
        var b13 = b[1 * 4 + 3];
        var b20 = b[2 * 4 + 0];
        var b21 = b[2 * 4 + 1];
        var b22 = b[2 * 4 + 2];
        var b23 = b[2 * 4 + 3];
        var b30 = b[3 * 4 + 0];
        var b31 = b[3 * 4 + 1];
        var b32 = b[3 * 4 + 2];
        var b33 = b[3 * 4 + 3];
        return [
          b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,
          b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,
          b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,
          b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,
          b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,
          b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,
          b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,
          b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,
          b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,
          b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,
          b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,
          b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,
          b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,
          b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,
          b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,
          b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33,
        ];
      },

      translation: function(tx, ty, tz) {
        return [
           1,  0,  0,  0,
           0,  1,  0,  0,
           0,  0,  1,  0,
           tx, ty, tz, 1,
        ];
      },

      xRotation: function(angleInRadians) {
        var c = Math.cos(angleInRadians);
        var s = Math.sin(angleInRadians);

        return [
          1, 0, 0, 0,
          0, c, s, 0,
          0, -s, c, 0,
          0, 0, 0, 1,
        ];
      },

      yRotation: function(angleInRadians) {
        var c = Math.cos(angleInRadians);
        var s = Math.sin(angleInRadians);

        return [
          c, 0, -s, 0,
          0, 1, 0, 0,
          s, 0, c, 0,
          0, 0, 0, 1,
        ];
      },

      zRotation: function(angleInRadians) {
        var c = Math.cos(angleInRadians);
        var s = Math.sin(angleInRadians);

        return [
           c, s, 0, 0,
          -s, c, 0, 0,
           0, 0, 1, 0,
           0, 0, 0, 1,
        ];
      },

      scaling: function(sx, sy, sz) {
        return [
          sx, 0,  0,  0,
          0, sy,  0,  0,
          0,  0, sz,  0,
          0,  0,  0,  1,
        ];
      },

      translate: function(m, tx, ty, tz) {
        return m4.multiply(m, m4.translation(tx, ty, tz));
      },

      xRotate: function(m, angleInRadians) {
        return m4.multiply(m, m4.xRotation(angleInRadians));
      },

      yRotate: function(m, angleInRadians) {
        return m4.multiply(m, m4.yRotation(angleInRadians));
      },

      zRotate: function(m, angleInRadians) {
        return m4.multiply(m, m4.zRotation(angleInRadians));
      },

      scale: function(m, sx, sy, sz) {
        return m4.multiply(m, m4.scaling(sx, sy, sz));
      },

    };

    ////////////////////////////////////////////////////////
    ///// ðŸ‘‰ CREATING AND COMPILING HELPER FUNCTIONS ///////
    ////////////////////////////////////////////////////////

    /**
     * Creates a program from 2 script tags.
     *
     * @param {!WebGLRenderingContext} gl The WebGL Context.
     * @param {string} vertexShaderId The id of the vertex shader script tag.
     * @param {string} fragmentShaderId The id of the fragment shader script tag.
     * @return {!WebGLProgram} A program
     */
    function createProgramFromScripts(
        gl, vertexShaderId, fragmentShaderId) {
      var vertexShader = createShaderFromScriptTag(gl, vertexShaderId);
      var fragmentShader = createShaderFromScriptTag(gl, fragmentShaderId);
      return createProgram(gl, vertexShader, fragmentShader);
    }

    /**
     * Creates a shader from the content of a script tag.
     *
     * @param {!WebGLRenderingContext} gl The WebGL Context.
     * @param {string} scriptId The id of the script tag.
     * @param {string} opt_shaderType. The type of shader to create.
     *     If not passed in will use the type attribute from the
     *     script tag.
     * @return {!WebGLShader} A shader.
     */
    function createShaderFromScriptTag(gl, scriptId, opt_shaderType) {
      // look up the script tag by id.
      var shaderScript = document.getElementById(scriptId);
      if (!shaderScript) {
        throw("*** Error: unknown script element" + scriptId);
      }

      // extract the contents of the script tag.
      var shaderSource = shaderScript.text;

      // If we didn't pass in a type, use the 'type' from
      // the script tag.
      if (!opt_shaderType) {
        if (shaderScript.type == "x-shader/x-vertex") {
          opt_shaderType = gl.VERTEX_SHADER;
        } else if (shaderScript.type == "x-shader/x-fragment") {
          opt_shaderType = gl.FRAGMENT_SHADER;
        } else if (!opt_shaderType) {
          throw("*** Error: shader type not set");
        }
      }

      return compileShader(gl, shaderSource, opt_shaderType);
    };

    /**
     * Creates and compiles a shader.
     *
     * @param {!WebGLRenderingContext} gl The WebGL Context.
     * @param {string} shaderSource The GLSL source code for the shader.
     * @param {number} shaderType The type of shader, VERTEX_SHADER or
     *     FRAGMENT_SHADER.
     * @return {!WebGLShader} The shader.
     */
    function compileShader(gl, shaderSource, shaderType) {
      // Create the shader object
      var shader = gl.createShader(shaderType);

      // Set the shader source code.
      gl.shaderSource(shader, shaderSource);

      // Compile the shader
      gl.compileShader(shader);

      // Check if it compiled
      var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
      if (!success) {
        // Something went wrong during compilation; get the error
        throw "could not compile shader:" + shaderSource + gl.getShaderInfoLog(shader);
      }

      return shader;
    }

    /**
     * Creates a program from 2 shaders.
     *
     * @param {!WebGLRenderingContext) gl The WebGL context.
     * @param {!WebGLShader} vertexShader A vertex shader.
     * @param {!WebGLShader} fragmentShader A fragment shader.
     * @return {!WebGLProgram} A program.
     */
    function createProgram(gl, vertexShader, fragmentShader) {
      // create a program.
      var program = gl.createProgram();

      // attach the shaders.
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);

      // link the program.
      gl.linkProgram(program);

      // Check if it linked.
      var success = gl.getProgramParameter(program, gl.LINK_STATUS);
      if (!success) {
          // something went wrong with the link
          throw ("program filed to link:" + gl.getProgramInfoLog (program));
      }

      return program;
    };




  </script>

</body>
</html>
