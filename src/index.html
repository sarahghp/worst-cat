<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>C U B E</title>
</head>
<body>
  <canvas id="c" width="1000" height="1000"></canvas>
  <script id="3d-vertex-shader" type="x-shader/x-vertex">

    attribute vec4 a_position;
    attribute vec2 a_texcoord;

    uniform mat4 u_matrix;
    varying vec2 v_texcoord;


    void main() {
      // Multiply the position by the matrix.
      gl_Position = u_matrix * a_position;
      v_texcoord = a_texcoord;
    }

  </script>

  <script id="3d-fragment-shader" type="x-shader/x-fragment">

    // fragment shaders don't have a default precision so we need
    // to pick one. mediump is a good default
    precision mediump float;

    // Passed in from the vertex shader.
    varying vec2 v_texcoord;

    // The texture.
    uniform sampler2D u_texture;

    void main() {
       gl_FragColor = texture2D(u_texture, v_texcoord);
    }

  </script>

  <script>

    console.log('Loaded.');
    window.onload = main;

    function main() {

      // create context
      const canvas = document.getElementById("c");
      const gl = canvas.getContext("webgl");

      if (!gl) {
       console.log('Wat, no gl.');
      }

      gl.clearColor(1.0, 1.0, 1.0, 1.0);  // Clear to white, fully opaque
      gl.clearDepth(1.0);                 // Clear everything
      gl.enable(gl.DEPTH_TEST);           // Enable depth testing
      gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

      var vertices = [
        // Front face
        0.0,    0.0,    100.0,
        100.0,  0.0,    100.0,
        100.0,  100.0,  100.0,
        0.0,    100.0,  100.0,

        // Back face
        0.0,    0.0,    0.0,
        0.0,    100.0,  0.0,
        100.0,  100.0,  0.0,
        100.0,  0.0,    0.0,

        // Top face
        0.0,    100.0,  0.0,
        0.0,    100.0,  100.0,
        100.0,  100.0,  100.0,
        100.0,  100.0,  0.0,

        // Bottom face
        0.0,    0.0,    0.0,
        100.0,  0.0,    0.0,
        100.0,  0.0,    100.0,
        0.0,    0.0,    100.0,

        // Right face
        100.0,    0.0,  0.0,
        100.0,  100.0,  0.0,
        100.0,  100.0,  100.0,
        100.0,    0.0,  100.0,

        // Left face
        0.0,    0.0,    0.0,
        0.0,    0.0,    100.0,
        0.0,  100.0,    100.0,
        0.0,  100.0,    0.0
      ];


      // This array defines each face as two triangles, using the
      // indices into the vertex array to specify each triangle's
      // position.

      var cubeVertexIndices = [
        0,  1,  2,      0,  2,  3,    // front
        4,  5,  6,      4,  6,  7,    // back
        8,  9,  10,     8,  10, 11,   // top
        12, 13, 14,     12, 14, 15,   // bottom
        16, 17, 18,     16, 18, 19,   // right
        20, 21, 22,     20, 22, 23    // left
      ];

      var program = createProgramFromScripts(gl, '3d-vertex-shader', '3d-fragment-shader');

      var positionLocation = gl.getAttribLocation(program, "a_position");
      var texcoordLocation = gl.getAttribLocation(program, "a_texcoord");

      var matrixLocation = gl.getUniformLocation(program, "u_matrix");
      var textureLocation = gl.getUniformLocation(program, "u_texture");

      var positionBuffer = gl.createBuffer();
      var texcoordBuffer = gl.createBuffer();

      var cubeVerticesIndexBuffer = gl.createBuffer();
      var texture = gl.createTexture();

      var initialMatrix = {
        translation  : [gl.canvas.clientWidth/3, gl.canvas.clientHeight/3, 40],
        rotation     : [1, 1, 1],
        scale        : [1, 1, 1],
      };

      let multiMatrix = Array(10000).fill(0).map((n) => {
        let myMat = Object.assign({}, initialMatrix);
        myMat.translation = [Math.random() * 1000, Math.random() * 1000, Math.random() * 40];
        myMat.rotation = [Math.random() * 7.28, Math.random() * 7.28, 1];
        return myMat;
      });

      // create, link, and use program
      gl.useProgram(program);

      // set attribute and uniform locations
      gl.enableVertexAttribArray(positionLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      gl.vertexAttribPointer(
            positionLocation, 3, gl.FLOAT, false, 0, 0);


      gl.enableVertexAttribArray(texcoordLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
      setTexcoords(gl);
      gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);


      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
          new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);


      gl.bindTexture(gl.TEXTURE_2D, texture);
      // Fill the texture with a 1x1 blue pixel.
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                    new Uint8Array([0, 0, 255, 255]));


      // Asynchronously load an image
      var image = new Image();
      image.src = "./txt_sized.png";
      image.addEventListener('load', function() {
        // Now that the image has loaded make copy it to the texture.
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, image);

        // Check if the image is a power of 2 in both dimensions.
        if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
          console.log('in if', image.width, image.height)
           // Yes, it's a power of 2. Generate mips.
           gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
           gl.generateMipmap(gl.TEXTURE_2D);
        } else {
          console.log('in else', image.width, image.height)
           // No, it's not a power of 2. Turn off mips and set wrapping to clamp to edge
           gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
           gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
           gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        }
      });

      gl.uniform1i(textureLocation, 0);


      function drawCube(translation, rotation, scale){
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        multiMatrix.forEach((mat) => {

          mat.rotation = mat.rotation.map((r, i) => r += (.01 * i));

          // Compute the matrix
          let matrix = m4.projection(1000, 1000, 400);
              matrix = m4.translate(matrix, mat.translation[0], mat.translation[1], mat.translation[2]);
              matrix = m4.xRotate(matrix, mat.rotation[0]);
              matrix = m4.yRotate(matrix, mat.rotation[1]);
              matrix = m4.zRotate(matrix, mat.rotation[2]);
              matrix = m4.scale(matrix, mat.scale[0], mat.scale[1], mat.scale[2]);

          // Set the matrix.
          gl.uniformMatrix4fv(matrixLocation, false, matrix);

          // Draw the cube.
          gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

        });

        requestAnimationFrame(drawCube.bind(null, translation, rotation, scale))
      }

      const initTranslation = [Math.random() * gl.canvas.clientWidth, Math.random() * gl.canvas.clientHeight, 40],
          initRotation    = [1, 1, 1],
          initScale       = [1, 1, 1];

      requestAnimationFrame(drawCube.bind(null, initTranslation, initRotation, initScale))
    }


    ////////////////////////////////////////////////////////
    ///// ðŸŽ† TEXTURE HELPER FUNCTION /////////////////////
    ////////////////////////////////////////////////////////

    // Fill the buffer with texture coordinates the cube.
    // These are also subject to the element array vertex indices
    function setTexcoords(gl) {
      gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(
            [

            // bottom left image
            0.0, 0.5,
            0.0, 0.0,
            0.25, 0.0,
            0.25, 0.5,

            // bottom middle image
            0.5, 0.0,
            0.25, 0.0,
            0.25, 0.5,
            0.5, 0.5,

            // bottom right image
            0.5 , 0.5,
            0.5 , 0.0,
            0.75, 0.0,
            0.75, 0.5,

            // top left image
            0.25, 0.5,
            0.0, 0.5,
            0.0, 1.0,
            0.25, 1.0,

            // select the top middle image
            0.25, 1.0,
            0.25, 0.5,
            0.5, 0.5,
            0.5, 1.0,

            // select the top right image
            0.75, 0.5,
            0.5, 0.5,
            0.5, 1.0,
            0.75, 1.0,

          ]),
          gl.STATIC_DRAW);
    }

    ////////////////////////////////////////////////////////
    ///// ðŸ”¢ MATHING HELPER FUNCTIONS /////////////////////
    ////////////////////////////////////////////////////////


    function isPowerOf2(value) {
      return (value & (value - 1)) == 0;
    }

    function plusOrMinus(range){
      var n = Math.random() * (range * 2); // .11 * (.02)
      return n - range;
    }

    function clamp(val, min, max, variation) {
      if (val > max) {
        return val - variation;
      } else if (val < min) {
        return val + variation;
      } else {
        return val;
      }
    }

    // All the matrix maths
    var m4 = {

      projection: function(width, height, depth) {
        // Note: This matrix flips the Y axis so 0 is at the top.
        return [
           2 / width, 0, 0, 0,
           0, -2 / height, 0, 0,
           0, 0, 2 / depth, 0,
          -1, 1, 0, 1,
        ];
      },

      multiply: function(a, b) {
        var a00 = a[0 * 4 + 0];
        var a01 = a[0 * 4 + 1];
        var a02 = a[0 * 4 + 2];
        var a03 = a[0 * 4 + 3];
        var a10 = a[1 * 4 + 0];
        var a11 = a[1 * 4 + 1];
        var a12 = a[1 * 4 + 2];
        var a13 = a[1 * 4 + 3];
        var a20 = a[2 * 4 + 0];
        var a21 = a[2 * 4 + 1];
        var a22 = a[2 * 4 + 2];
        var a23 = a[2 * 4 + 3];
        var a30 = a[3 * 4 + 0];
        var a31 = a[3 * 4 + 1];
        var a32 = a[3 * 4 + 2];
        var a33 = a[3 * 4 + 3];
        var b00 = b[0 * 4 + 0];
        var b01 = b[0 * 4 + 1];
        var b02 = b[0 * 4 + 2];
        var b03 = b[0 * 4 + 3];
        var b10 = b[1 * 4 + 0];
        var b11 = b[1 * 4 + 1];
        var b12 = b[1 * 4 + 2];
        var b13 = b[1 * 4 + 3];
        var b20 = b[2 * 4 + 0];
        var b21 = b[2 * 4 + 1];
        var b22 = b[2 * 4 + 2];
        var b23 = b[2 * 4 + 3];
        var b30 = b[3 * 4 + 0];
        var b31 = b[3 * 4 + 1];
        var b32 = b[3 * 4 + 2];
        var b33 = b[3 * 4 + 3];
        return [
          b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,
          b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,
          b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,
          b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,
          b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,
          b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,
          b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,
          b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,
          b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,
          b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,
          b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,
          b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,
          b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,
          b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,
          b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,
          b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33,
        ];
      },

      translation: function(tx, ty, tz) {
        return [
           1,  0,  0,  0,
           0,  1,  0,  0,
           0,  0,  1,  0,
           tx, ty, tz, 1,
        ];
      },

      xRotation: function(angleInRadians) {
        var c = Math.cos(angleInRadians);
        var s = Math.sin(angleInRadians);

        return [
          1, 0, 0, 0,
          0, c, s, 0,
          0, -s, c, 0,
          0, 0, 0, 1,
        ];
      },

      yRotation: function(angleInRadians) {
        var c = Math.cos(angleInRadians);
        var s = Math.sin(angleInRadians);

        return [
          c, 0, -s, 0,
          0, 1, 0, 0,
          s, 0, c, 0,
          0, 0, 0, 1,
        ];
      },

      zRotation: function(angleInRadians) {
        var c = Math.cos(angleInRadians);
        var s = Math.sin(angleInRadians);

        return [
           c, s, 0, 0,
          -s, c, 0, 0,
           0, 0, 1, 0,
           0, 0, 0, 1,
        ];
      },

      scaling: function(sx, sy, sz) {
        return [
          sx, 0,  0,  0,
          0, sy,  0,  0,
          0,  0, sz,  0,
          0,  0,  0,  1,
        ];
      },

      translate: function(m, tx, ty, tz) {
        return m4.multiply(m, m4.translation(tx, ty, tz));
      },

      xRotate: function(m, angleInRadians) {
        return m4.multiply(m, m4.xRotation(angleInRadians));
      },

      yRotate: function(m, angleInRadians) {
        return m4.multiply(m, m4.yRotation(angleInRadians));
      },

      zRotate: function(m, angleInRadians) {
        return m4.multiply(m, m4.zRotation(angleInRadians));
      },

      scale: function(m, sx, sy, sz) {
        return m4.multiply(m, m4.scaling(sx, sy, sz));
      },

    };

    ////////////////////////////////////////////////////////
    ///// ðŸ‘‰ CREATING AND COMPILING HELPER FUNCTIONS ///////
    ////////////////////////////////////////////////////////

    /**
     * Creates a program from 2 script tags.
     *
     * @param {!WebGLRenderingContext} gl The WebGL Context.
     * @param {string} vertexShaderId The id of the vertex shader script tag.
     * @param {string} fragmentShaderId The id of the fragment shader script tag.
     * @return {!WebGLProgram} A program
     */
    function createProgramFromScripts(
        gl, vertexShaderId, fragmentShaderId) {
      var vertexShader = createShaderFromScriptTag(gl, vertexShaderId);
      var fragmentShader = createShaderFromScriptTag(gl, fragmentShaderId);
      return createProgram(gl, vertexShader, fragmentShader);
    }

    /**
     * Creates a shader from the content of a script tag.
     *
     * @param {!WebGLRenderingContext} gl The WebGL Context.
     * @param {string} scriptId The id of the script tag.
     * @param {string} opt_shaderType. The type of shader to create.
     *     If not passed in will use the type attribute from the
     *     script tag.
     * @return {!WebGLShader} A shader.
     */
    function createShaderFromScriptTag(gl, scriptId, opt_shaderType) {
      // look up the script tag by id.
      var shaderScript = document.getElementById(scriptId);
      if (!shaderScript) {
        throw("*** Error: unknown script element" + scriptId);
      }

      // extract the contents of the script tag.
      var shaderSource = shaderScript.text;

      // If we didn't pass in a type, use the 'type' from
      // the script tag.
      if (!opt_shaderType) {
        if (shaderScript.type == "x-shader/x-vertex") {
          opt_shaderType = gl.VERTEX_SHADER;
        } else if (shaderScript.type == "x-shader/x-fragment") {
          opt_shaderType = gl.FRAGMENT_SHADER;
        } else if (!opt_shaderType) {
          throw("*** Error: shader type not set");
        }
      }

      return compileShader(gl, shaderSource, opt_shaderType);
    };

    /**
     * Creates and compiles a shader.
     *
     * @param {!WebGLRenderingContext} gl The WebGL Context.
     * @param {string} shaderSource The GLSL source code for the shader.
     * @param {number} shaderType The type of shader, VERTEX_SHADER or
     *     FRAGMENT_SHADER.
     * @return {!WebGLShader} The shader.
     */
    function compileShader(gl, shaderSource, shaderType) {
      // Create the shader object
      var shader = gl.createShader(shaderType);

      // Set the shader source code.
      gl.shaderSource(shader, shaderSource);

      // Compile the shader
      gl.compileShader(shader);

      // Check if it compiled
      var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
      if (!success) {
        // Something went wrong during compilation; get the error
        throw "could not compile shader:" + shaderSource + gl.getShaderInfoLog(shader);
      }

      return shader;
    }

    /**
     * Creates a program from 2 shaders.
     *
     * @param {!WebGLRenderingContext) gl The WebGL context.
     * @param {!WebGLShader} vertexShader A vertex shader.
     * @param {!WebGLShader} fragmentShader A fragment shader.
     * @return {!WebGLProgram} A program.
     */
    function createProgram(gl, vertexShader, fragmentShader) {
      // create a program.
      var program = gl.createProgram();

      // attach the shaders.
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);

      // link the program.
      gl.linkProgram(program);

      // Check if it linked.
      var success = gl.getProgramParameter(program, gl.LINK_STATUS);
      if (!success) {
          // something went wrong with the link
          throw ("program filed to link:" + gl.getProgramInfoLog (program));
      }

      return program;
    };




  </script>

</body>
</html>
